Const MaxN=100;
Var SmallSc:Array[0..MaxN,0..MaxN] Of LongInt;
{*Нулевой столбец и нулевая строка необходимы,
это позволяет обойтись без анализа на выход
за пределы массива.*}
Procedure FillSmallSc;
Var i,j :Integer;
Begin
    FillChar (SmallSc,SizeOf(SmallSc),0);
    For i:=0 To N Do SmallSc [i,0]:=1;
    For i:=1 To N Do
        For j:=1 To k Do
            If SmallSc[i-1,j]*1.0+SmallSc[i-1,j-1]>MaxLonglnt Then
                SmallSc[i,j]:=MaxLongInt
            Else
                SmallSc[i,j]:=SmallSc[i-1,j]+SmallSc[i-1,j-1];
            {*Умножение на 1.0 переводит
            целое число в вещественное, поэтому
            переполнения при сложении не происходит.
            Стандартный прием, обязательный при "игре"
            на границах диапазона целых чисел.*}
End;

Type SmallSc=Array[0..MaxN] Of LongInt;
Function Res(k:Integer): LongInt;
Var A,B:SmallSc;
i,j:Integer;
Begin
    FillChar (A,SizeOf (A),0) ;
    FillChar(BrSizeOf(B),0) ;
    A[0]:=1;A[1]=1;
    For i:=1 To N Do Begin
        B[0] :=1; B[1] :=1;
        For j : = 1 To k Do В [j]:=A[j]+A[j-1]; 
        {*Если число
        больше максимального значения типа LongInt,
        то необходимо работать с "длинной"
        арифметикой. Данная операция должна быть
        изменена - вызов процедуры сложения двух
        "длинных" чисел.*}
        А:=В;
    End;
    Res:=A[k];
End;

Procedure GetWhByNum (L:LongInt);
Var i,j,sc,ls:Integer;
Begin
    sc:=n;
    ls:=0; {*Цифра сочетания.*}
    For i:=1 To k Do Begin
        {*i - номер элемента
        в сочетании; k-i - число элементов
        в сочетании.*}
        j:=1; {*sc-j - число элементов (п), из которых
        формируется сочетание.*}
        While L-SmallSc[sc-j,k-i]>=0 Do Веgiп
            {*Для данной позиции в сочетании и числа
            элементов в сочетании находим тот элемент
            массива SmallSc, который превышает
            текущее значение L.*}
            Dec (L,SmallSc[sc-j ,k-i]) ;
            Inc (j); {*Невыполнение условия цикла While
            говорит о том, что мы нашли строку
            таблицы SmallSc, т.е. то количество
            элементов, из которых формируется
            очередное сочетание, или тот интервал
            номеров сочетаний (относительно
            предыдущей цифры), в котором находится
            текущее значение номера L.*}
        End;
        С[i]:=ls+j; {*Предыдущая цифра плюс приращение.*}
        Inc(ls,j); {*Изменяем зна чение текущей цифры сочетания.*}
        Dec (sc,j); {*Изменяем количество элементов, из которых формируется остаток сочетания.*}
    End;
End;

{*Предполагается, что текущее сочетание (хранится в массиве С) 
не является последним.*}
Procedure NextСombinations;
Var i,j:Integer;
Begin
    i:=k;
    {*Находим элемент, который можно увеличить.*}
    While (C[i]+k-i+1>N) Do Dec(i);
    {*Увеличиваем на единицу.*}
    Inc(С[i]);
    {*Изменяем стоящие справа элементы.*}
    For j:=i+1 To k Do С[j]:=С[j-1]+1; 
End;
